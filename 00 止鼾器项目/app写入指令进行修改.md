---
创建时间: Invalid date
上次编辑者: wwang.wenping
上次编辑时间: Invalid date
---
### 概述

根据压力测试，目前的架构，嵌入式端对FFE1进行加密传输，以及app端对嵌入式进行写入操作（加密）。会导致嵌入式资源消耗过大，偶发导致蓝牙断开等异常。现修改相关操作

- 启动时，对FFE1进行写操作，启动硬件。
- 启动后，治疗过程中的操作，均对FFE3进行操作（包括之前的对收到的FFE1校验，也修改为对FFE3进行校验操作）。

### 电池电量获取修改：

- 进入治疗前，电池电量低检查，电池电量数据获取修改为，主动读取“00002a19-0000-1000-8000-00805f9b34fb”获取电池电量。同其他治疗前检查设备信息获取数据一样，主动读取仅在治疗前检查时使用，读取到数据后，即停止读取（后续整个治疗过程中都不允许再读取这些值了，降低设备运行负担）。
- 进入治疗后，电池电量数据获取，修改为，使用FFE3 notify的数据解析出来电池电量。（参考下方的修改）

### 写入操作修改：

- 仅在首页点击“开始治疗”时，使用现有的写入指令操作方式不变（此时仍然是同样的加密方式向FFE1写入指令）；
- 进入治疗后（包括结束治疗），所有的写操作，改为明文写入到FFE3，主要目的是降低硬件加解密的压力；

### 治疗过程中通信数据获取修改：

- 取消FFE1的notify数据获取，现在硬件在被启动治疗后，不会通过FFE1 notify加密的通信数据了，改为通过FFE3 notify明文数据；
- 开启FFE3 notify功能，治疗开始后，FFE3 明文notify硬件数据，数据解析不再需要解密；注：FFE3数据格式与FFE1一模一样，是FFE1的明文，其解析仅需要去掉原来的解密过程即可。

### 治疗过程中FFE1数据校验修改：

大量测试发现，当通信数据校验失败，有些情况下直接写入指令是一定无法成功写入指令的，可能是此时底层蓝牙协议栈已经阻塞了，所以需要先重启一次蓝牙，才可以写入成功。

对于蓝牙重启，已经在安卓端测试验证过，流程是close()→Scan()→…完成连接，注意不能操作disconnect()，因为硬件认为是app主动断开蓝牙，重置治疗状态了（即硬件端会绿灯闪烁，完全结束本次治疗了）。对应iOS端，如何操作，仅供参考。

- 参考上面修改，FFE1数据校验，对应改为FFE3数据校验；
- 通信数据（现在为FFE3数据）==**新鲜校验**==，原来逻辑多次没有收到新鲜数据，就直接写入一次指令。修改为，2次数据不新鲜，则先重启一次蓝牙连接流程，完成连接后再往FFE3写入当前状态、档位，以恢复数据不新鲜的问题。
- 通信数据（现在为FFE3数据）==**档位校验**==，原来逻辑多次档位不一致，就直接写入一次指令。修改为，2次档位不一致，则先重启一次蓝牙连接流程，完成连接后再往FFE3写入当前状态、档位，以恢复数据不新鲜的问题。
- 通信数据（现在为FFE3数据）==**非工作中校验**==，参考下图中异常状态定义（根据FFE3数据中字节2、字节4(bit7、bit5)），原来逻辑中，检验到非工作中，就会直接终止，实际测试发现这是硬件输出异常导致的（但是原因还未知），此时蓝牙并没有问题，所以APP可以补救恢复正常。补救恢复措施为，同数据新鲜、档位检验一样，2次非工作中，则往FFE3写入一次当前本地的档位、状态。注：不需要向前面那样，重启蓝牙，再写入。

![[image 13.png|image 13.png]]

- 通信数据（现在为FFE3数据）其他逻辑不变。